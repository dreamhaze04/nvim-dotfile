local ls = require("luasnip") -- 引入 LuaSnip

-- 定义一些快捷函数
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node
local d = ls.dynamic_node
local sn = ls.snippet_node
-- 定义 C++ 代码片段
ls.add_snippets("cpp", {
    s("acm", {
        t({ "#include <bits/stdc++.h>",
            "using namespace std;",
            "using i64 = long long;",
            "",
            "int main() {",
            "\tios::sync_with_stdio(false); cin.tie(nullptr);",
            "",
            "\t" }), i(1), -- 插入点 1
        t({ "", "",
            "\treturn 0;",
            "",
            "}" }),
    }),
    s("acms", {
        t({ "#include <bits/stdc++.h>",
            "using namespace std;",
            "using i64 = long long;",
            "" }),
        t({ "", "void solve() {" }),
        t({ "", "\t" }), i(1, ""),
        t({ "", "}", "" }),
        t({ "", "int main() {",
            "\tios::sync_with_stdio(false); cin.tie(nullptr);" }),
        t({ "", "\tint t; cin >> t;" }),
        t({ "", "\twhile (t--) { solve(); }" }),
        t({ "", "\treturn 0;", }),
        t({ "", "}" }),
    }),
    s("DSU", {
        t({ "struct DSU {",
            "\tstd::vector<int> f, siz;",
            "\t",
            "\tDSU() {}",
            "\tDSU(int n) {",
            "\t\tinit(n);",
            "\t}",
            "\tvoid init(int n) {",
            "\t\tf.resize(n);",
            "\t\tstd::iota(f.begin(), f.end(), 0);",
            "\t\tsiz.assign(n, 1);",
            "\t}",
            "\tint find(int x) {",
            "\t\twhile (x != f[x]) {",
            "\t\t\tx = f[x] = f[f[x]];",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "\tbool same(int x, int y) {",
            "\t\treturn find(x) == find(y);",
            "\t}",
            "\tbool merge(int x, int y) {",
            "\t\tx = find(x);",
            "\t\ty = find(y);",
            "\t\tif (x == y) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\tsiz[x] += siz[y];",
            "\t\tf[y] = x;",
            "\t\treturn true;",
            "\t}",
            "\tint size(int x) {",
            "\t\treturn siz[find(x)];",
            "\t}",
            "};", })
    }),
    s("dijkstra", {
        t({ "vector<i64> Dijkstra(int n, int start, vector<vector<pair<int, i64>>> & adj) {",
            "\tvector<i64> dis(n, -1);",
            "\tpriority_queue<pair<i64, int>, vector<pair<i64, int>>, greater<>> q;",
            "\tq.emplace(0, start);",
            "\twhile (q.size()) {",
            "\t\tauto [d, x] = q.top(); q.pop();",
            "\t\tif (dis[x] != -1) continue;",
            "\t\tdis[x] = d;",
            "\t\tfor (auto [y, w] : adj[x]) {",
            "\t\t\tq.emplace(w + d, y);",
            "\t\t}",
            "\t}",
            "\treturn dis;",
            "}" })
    }),
    s("spfa", {
        t({
            "bool spfa(int n, vector<vector<pair<int, i64>>> & adj) {",
            "\tvector<int> dis(n, inf);",
            "\tvector<bool> in_queue(n);",
            "\tvector<int> cnt(n);",
            "\tqueue<int> q;",
            "\tq.push(0);",
            "\tdis[0] = 0;",
            "\tin_queue[0] = true;",
            "\twhile (q.size()) {",
            "\t\tint from = q.front(); q.pop();",
            "\t\tin_queue[from] = false;",
            "\t\tfor (auto [to, w] : adj[from]) {",
            "\t\t\tif (dis[to] > dis[from] + w) {",
            "\t\t\t\tdis[to] = dis[from] + w;",
            "\t\t\t\tif (!in_queue[to]) {",
            "\t\t\t\t\tq.push(to);",
            "\t\t\t\t\tin_queue[to] = true;",
            "\t\t\t\t\tcnt[to] ++;",
            "\t\t\t\t\tif (cnt[to] == n) return true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn false;",
            "};"
        })
    }),
    s("LazySegmentTree", {
        t({ "template<class Info, class Tag>",
            "struct LazySegmentTree {",
            "\tint n;",
            "\tstd::vector<Info> info;",
            "\tstd::vector<Tag> tag;",
            "\tLazySegmentTree() : n(0) {}",
            "\tLazySegmentTree(int n_, Info v_ = Info()) {",
            "\t\tinit(n_, v_);",
            "\t}",
            "\ttemplate<class T>",
            "\tLazySegmentTree(std::vector<T> init_) {",
            "\t\tinit(init_);",
            "\t}",
            "\tvoid init(int n_, Info v_ = Info()) {",
            "\t\tinit(std::vector(n_, v_));",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid init(std::vector<T> init_) {",
            "\t\tn = init_.size();",
            "\t\tinfo.assign(4 << std::__lg(n), Info());",
            "\t\ttag.assign(4 << std::__lg(n), Tag());",
            "\t\tstd::function<void(int, int, int)> build = [&](int p, int l, int r) {",
            "\t\t\tif (r - l == 1) {",
            "\t\t\t\tinfo[p] = init_[l];",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\tint m = (l + r) / 2;",
            "\t\t\tbuild(2 * p, l, m);",
            "\t\t\tbuild(2 * p + 1, m, r);",
            "\t\t\tpull(p);",
            "\t\t};",
            "\t\tbuild(1, 0, n);",
            "\t}",
            "\tvoid pull(int p) {",
            "\t\tinfo[p] = info[2 * p] + info[2 * p + 1];",
            "\t}",
            "\tvoid apply(int p, const Tag &v) {",
            "\t\tinfo[p].apply(v);",
            "\t\ttag[p].apply(v);",
            "\t}",
            "\tvoid push(int p) {",
            "\t\tapply(2 * p, tag[p]);",
            "\t\tapply(2 * p + 1, tag[p]);",
            "\t\ttag[p] = Tag();",
            "\t}",
            "\tvoid modify(int p, int l, int r, int x, const Info &v) {",
            "\t\tif (r - l == 1) {",
            "\t\t\tinfo[p] = v;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\tif (x < m) {",
            "\t\t\tmodify(2 * p, l, m, x, v);",
            "\t\t} else {",
            "\t\t\tmodify(2 * p + 1, m, r, x, v);",
            "\t\t}",
            "\t\tpull(p);",
            "\t}",
            "\tvoid modify(int p, const Info &v) {",
            "\t\tmodify(1, 0, n, p, v);",
            "\t}",
            "\tInfo rangeQuery(int p, int l, int r, int x, int y) {",
            "\t\tif (l >= y || r <= x) {",
            "\t\t\treturn Info();",
            "\t\t}",
            "\t\tif (l >= x && r <= y) {",
            "\t\t\treturn info[p];",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\treturn rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
            "\t}",
            "\tInfo rangeQuery(int l, int r) {",
            "\t\treturn rangeQuery(1, 0, n, l, r);",
            "\t}",
            "\tvoid rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
            "\t\tif (l >= y || r <= x) {",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (l >= x && r <= y) {",
            "\t\t\tapply(p, v);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\trangeApply(2 * p, l, m, x, y, v);",
            "\t\trangeApply(2 * p + 1, m, r, x, y, v);",
            "\t\tpull(p);",
            "\t}",
            "\tvoid rangeApply(int l, int r, const Tag &v) {",
            "\t\treturn rangeApply(1, 0, n, l, r, v);",
            "\t}",
            "\tvoid half(int p, int l, int r) {",
            "\t\tif (info[p].act == 0) {",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {",
            "\t\t\tapply(p, {-(info[p].min + 1) / 2});",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\thalf(2 * p, l, m);",
            "\t\thalf(2 * p + 1, m, r);",
            "\t\tpull(p);",
            "\t}",
            "\tvoid half() {",
            "\t\thalf(1, 0, n);",
            "\t}",
            "\t",
            "\ttemplate<class F>",
            "\tint findFirst(int p, int l, int r, int x, int y, F &&pred) {",
            "\t\tif (l >= y || r <= x) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (l >= x && r <= y && !pred(info[p])) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (r - l == 1) {",
            "\t\t\treturn l;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\tint res = findFirst(2 * p, l, m, x, y, pred);",
            "\t\tif (res == -1) {",
            "\t\t\tres = findFirst(2 * p + 1, m, r, x, y, pred);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class F>",
            "\tint findFirst(int l, int r, F &&pred) {",
            "\t\treturn findFirst(1, 0, n, l, r, pred);",
            "\t}",
            "\ttemplate<class F>",
            "\tint findLast(int p, int l, int r, int x, int y, F &&pred) {",
            "\t\tif (l >= y || r <= x) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (l >= x && r <= y && !pred(info[p])) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (r - l == 1) {",
            "\t\t\treturn l;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\tint res = findLast(2 * p + 1, m, r, x, y, pred);",
            "\t\tif (res == -1) {",
            "\t\t\tres = findLast(2 * p, l, m, x, y, pred);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class F>",
            "\tint findLast(int l, int r, F &&pred) {",
            "\t\treturn findLast(1, 0, n, l, r, pred);",
            "\t}",
            "\t",
            "\tvoid maintainL(int p, int l, int r, int pre) {",
            "\t\tif (info[p].difl > 0 && info[p].maxlowl < pre) {",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (r - l == 1) {",
            "\t\t\tinfo[p].max = info[p].maxlowl;",
            "\t\t\tinfo[p].maxl = info[p].maxr = l;",
            "\t\t\tinfo[p].maxlowl = info[p].maxlowr = -inf;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\tmaintainL(2 * p, l, m, pre);",
            "\t\tpre = std::max(pre, info[2 * p].max);",
            "\t\tmaintainL(2 * p + 1, m, r, pre);",
            "\t\tpull(p);",
            "\t}",
            "\tvoid maintainL() {",
            "\t\tmaintainL(1, 0, n, -1);",
            "\t}",
            "\tvoid maintainR(int p, int l, int r, int suf) {",
            "\t\tif (info[p].difr > 0 && info[p].maxlowr < suf) {",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (r - l == 1) {",
            "\t\t\tinfo[p].max = info[p].maxlowl;",
            "\t\t\tinfo[p].maxl = info[p].maxr = l;",
            "\t\t\tinfo[p].maxlowl = info[p].maxlowr = -inf;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = (l + r) / 2;",
            "\t\tpush(p);",
            "\t\tmaintainR(2 * p + 1, m, r, suf);",
            "\t\tsuf = std::max(suf, info[2 * p + 1].max);",
            "\t\tmaintainR(2 * p, l, m, suf);",
            "\t\tpull(p);",
            "\t}",
            "\tvoid maintainR() {",
            "\t\tmaintainR(1, 0, n, -1);",
            "\t}",
            "};",
            "",
            "struct Tag {",
            "\tint x = 0;",
            "\tvoid apply(const Tag &t) & {",
            "\t\tx = std::max(x, t.x);",
            "\t}",
            "};",
            "",
            "struct Info {",
            "\tint x = 0;",
            "\tvoid apply(const Tag &t) & {",
            "\t\tx = std::max(x, t.x);",
            "\t}",
            "};",
            "",
            "Info operator+(const Info &a, const Info &b) {",
            "\treturn {std::max(a.x, b.x)};",
            "}", })
    }),
})
